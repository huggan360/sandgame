<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tropical Sips: Party Island</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #87CEEB; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; user-select: none; }
        canvas { display: block; width: 100vw; height: 100vh; outline: none; }
        
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        /* HUD */
        .hud-top { display: flex; justify-content: space-between; width: 100%; }
        .player-score { font-size: 1.5rem; font-weight: bold; padding: 10px 20px; border-radius: 10px; background: rgba(0,0,0,0.5); color: white; border: 2px solid; }
        .p1-hud { border-color: #00ffaa; color: #00ffaa; }
        .p2-hud { border-color: #ff00ff; color: #ff00ff; }

        h1 { margin: 0; font-size: 3rem; color: #FFD700; -webkit-text-stroke: 1px #B8860B; }
        h2 { margin: 10px 0; font-size: 1.5rem; color: white; }

        /* Dialog Cards */
        .card {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(20, 30, 40, 0.95);
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 0 50px rgba(0,255,255,0.2);
            border: 2px solid #00ffff;
            pointer-events: auto;
            display: none;
            z-index: 10;
        }

        .card.active { display: block; animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275); }

        .btn {
            background: linear-gradient(45deg, #FF512F, #DD2476);
            border: none;
            padding: 15px 40px;
            color: white;
            font-size: 1.2rem;
            font-weight: bold;
            border-radius: 50px;
            cursor: pointer;
            margin-top: 20px;
            transition: transform 0.1s;
            text-transform: uppercase;
            box-shadow: 0 5px 15px rgba(221, 36, 118, 0.4);
        }
        .btn:hover { transform: scale(1.05); }
        .btn:active { transform: scale(0.95); }

        .controls-hint {
            display: flex;
            justify-content: space-around;
            margin-top: 20px;
            font-size: 0.9rem;
            color: #ccc;
            background: rgba(0,0,0,0.3);
            padding: 10px;
            border-radius: 10px;
        }
        .key { border: 1px solid #777; padding: 2px 6px; border-radius: 4px; background: #333; color: white; font-family: monospace; }

        @keyframes popIn { from { transform: translate(-50%, -40%) scale(0.9); opacity: 0; } to { transform: translate(-50%, -50%) scale(1); opacity: 1; } }
        
        #game-timer { font-size: 2rem; color: yellow; font-weight: bold; text-shadow: 2px 2px black; display: none; }

        /* WHEEL UI */
        #wheel-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); display: none;
            flex-direction: column; align-items: center; justify-content: center;
            pointer-events: auto; z-index: 20;
        }
        #wheel-overlay.active { display: flex; }
        
        #wheel-container { position: relative; margin: 20px; }
        
        #wheel {
            width: 300px; height: 300px; border-radius: 50%; border: 8px solid white;
            /* Red: Brawl, Green: Survival, Gold: Collect */
            background: conic-gradient(
                #FF512F 0deg 120deg, 
                #228B22 120deg 240deg, 
                #FFD700 240deg 360deg
            );
            transition: transform 3s cubic-bezier(0.1, 0.7, 0.1, 1);
            box-shadow: 0 0 30px rgba(0,0,0,0.5);
        }
        
        #pointer {
            width: 0; height: 0; 
            border-left: 20px solid transparent; 
            border-right: 20px solid transparent; 
            border-top: 40px solid white;
            position: absolute; top: -25px; left: 50%; 
            transform: translateX(-50%); 
            z-index: 25;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.5));
        }

        .wheel-legend {
            display: flex; gap: 20px; color: white; margin-top: 20px; font-weight: bold; text-shadow: 1px 1px 2px black;
        }
        .legend-item span { display: inline-block; width: 15px; height: 15px; margin-right: 5px; border: 2px solid white; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="ui-layer">
        <div class="hud-top">
            <div class="player-score p1-hud">P1 (Green)</div>
            <div id="game-timer">30</div>
            <div class="player-score p2-hud">P2 (Pink)</div>
        </div>

        <!-- Wheel UI -->
        <div id="wheel-overlay">
            <h1>SPINNING FOR FATE...</h1>
            <div id="wheel-container">
                <div id="pointer"></div>
                <div id="wheel"></div>
            </div>
            <div class="wheel-legend">
                <div class="legend-item"><span style="background: #FF512F;"></span>BRAWL</div>
                <div class="legend-item"><span style="background: #228B22;"></span>SURVIVAL</div>
                <div class="legend-item"><span style="background: #FFD700;"></span>COLLECT</div>
            </div>
        </div>

        <!-- Lobby UI -->
        <div id="lobby-card" class="card active">
            <h1>TROPICAL LOBBY</h1>
            <p style="color: #aaa;">2 Players Ready</p>
            <div class="controls-hint">
                <div>P1: <span class="key">WASD</span> + <span class="key">SPACE</span></div>
                <div>P2: <span class="key">ARROWS</span> + <span class="key">ENTER</span></div>
            </div>
            <button class="btn" onclick="GameManager.spinWheel()">START ROUND</button>
        </div>

        <!-- Result UI -->
        <div id="result-card" class="card">
            <h1 id="winner-text">PLAYER 1 WINS!</h1>
            <div style="font-size: 4rem; margin: 20px 0;">üç∫</div>
            <h2 id="loser-task" style="color: #FF512F;">Loser drinks 1 sip</h2>
            <button class="btn" onclick="GameManager.returnToLobby()">BACK TO LOBBY</button>
        </div>
        
        <!-- Game Intro UI -->
        <div id="intro-card" class="card">
            <h1 id="game-title">MINIGAME</h1>
            <p id="game-desc">Description goes here</p>
            <h3 style="color: yellow">LOSER PENALTY: <span id="game-penalty">1 Sip</span></h3>
            <div id="countdown" style="font-size: 3rem; margin-top: 20px; font-weight: bold;">3</div>
        </div>
    </div>

    <script>
        // --- INPUT MANAGER ---
        const Input = {
            keys: {},
            init() {
                window.addEventListener('keydown', e => this.keys[e.code] = true);
                window.addEventListener('keyup', e => this.keys[e.code] = false);
            },
            getP1Axis() {
                let x = 0, z = 0;
                if (this.keys['KeyA']) x -= 1;
                if (this.keys['KeyD']) x += 1;
                if (this.keys['KeyW']) z -= 1;
                if (this.keys['KeyS']) z += 1;
                return { x, z, action: this.keys['Space'] };
            },
            getP2Axis() {
                let x = 0, z = 0;
                // Arrows
                if (this.keys['ArrowLeft'] || this.keys['Numpad4']) x -= 1;
                if (this.keys['ArrowRight'] || this.keys['Numpad6']) x += 1;
                if (this.keys['ArrowUp'] || this.keys['Numpad8']) z -= 1;
                if (this.keys['ArrowDown'] || this.keys['Numpad5'] || this.keys['Numpad2']) z += 1;
                return { x, z, action: this.keys['Enter'] || this.keys['Numpad0'] || this.keys['NumpadEnter'] };
            }
        };
        Input.init();

        // --- THREE.JS SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 20, 60);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffdfba, 1);
        dirLight.position.set(10, 30, 10);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        dirLight.shadow.camera.left = -20;
        dirLight.shadow.camera.right = 20;
        dirLight.shadow.camera.top = 20;
        dirLight.shadow.camera.bottom = -20;
        scene.add(dirLight);

        // --- ASSETS & SHARED MATERIALS ---
        const mats = {
            p1: new THREE.MeshStandardMaterial({ color: 0x00ffaa }),
            p2: new THREE.MeshStandardMaterial({ color: 0xff00ff }),
            sand: new THREE.MeshStandardMaterial({ color: 0xF4A460 }),
            water: new THREE.MeshStandardMaterial({ color: 0x006994, transparent: true, opacity: 0.8 }),
            wood: new THREE.MeshStandardMaterial({ color: 0x8B4513 }),
            leaf: new THREE.MeshStandardMaterial({ color: 0x228B22 }),
            red: new THREE.MeshStandardMaterial({ color: 0xff3333 }),
            gold: new THREE.MeshStandardMaterial({ color: 0xFFD700, metalness: 0.5, roughness: 0.2 }),
            crate: new THREE.MeshStandardMaterial({ color: 0x8B4513 }),
            shadow: new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.3 })
        };

        // --- SCENE GENERATION ---
        const islandGroup = new THREE.Group();
        scene.add(islandGroup);
        const ocean = new THREE.Mesh(new THREE.PlaneGeometry(300, 300), mats.water);
        ocean.rotation.x = -Math.PI/2;
        ocean.position.y = -0.5;
        scene.add(ocean);

        // Island Base
        const island = new THREE.Mesh(new THREE.CylinderGeometry(14, 14, 1, 32), mats.sand);
        island.position.y = -0.5;
        island.receiveShadow = true;
        islandGroup.add(island);

        // Minigame Platform (Hidden by default, used for arenas)
        const arena = new THREE.Mesh(new THREE.CylinderGeometry(9, 9, 0.5, 32), new THREE.MeshStandardMaterial({color: 0x444444}));
        arena.position.y = 100; // Hide initially
        arena.receiveShadow = true;
        scene.add(arena);

        // Decoration
        function createPalm(x, z) {
            const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.2, 3, 6), mats.wood);
            trunk.position.set(x, 1, z);
            trunk.castShadow = true;
            islandGroup.add(trunk);
            const leaves = new THREE.Mesh(new THREE.ConeGeometry(1.5, 1, 5), mats.leaf);
            leaves.position.set(x, 2.5, z);
            islandGroup.add(leaves);
        }
        for(let i=0; i<8; i++) {
            const a = i/8 * Math.PI*2;
            createPalm(Math.cos(a)*10, Math.sin(a)*10);
        }

        // Totem
        const totem = new THREE.Group();
        const b1 = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), mats.wood); b1.position.y=0.5;
        const b2 = new THREE.Mesh(new THREE.BoxGeometry(0.8,0.8,0.8), mats.red); b2.position.y=1.4;
        totem.add(b1, b2);
        totem.castShadow = true;
        islandGroup.add(totem);

        // --- PLAYER OBJECTS ---
        function createPlayerMesh(mat) {
            const group = new THREE.Group();
            // Replaced CapsuleGeometry with CylinderGeometry for compatibility with r128
            const body = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.4, 1.6, 12), mat);
            body.position.y = 0.8;
            body.castShadow = true;
            
            // Eyes attached to body to move with it
            const eyeGeo = new THREE.BoxGeometry(0.1, 0.1, 0.1);
            const eyeMat = new THREE.MeshBasicMaterial({color:0x000000});
            const e1 = new THREE.Mesh(eyeGeo, eyeMat); 
            e1.position.set(0.15, 0.5, 0.35); // Adjusted for cylinder relative coords
            const e2 = new THREE.Mesh(eyeGeo, eyeMat); 
            e2.position.set(-0.15, 0.5, 0.35);
            
            body.add(e1);
            body.add(e2);
            group.add(body);
            return group;
        }

        const p1Mesh = createPlayerMesh(mats.p1);
        const p2Mesh = createPlayerMesh(mats.p2);
        scene.add(p1Mesh, p2Mesh);

        // Projectiles / Objects Pool
        let gameObjects = [];

        // --- GAME LOGIC ---

        const GameManager = {
            state: 'LOBBY', // LOBBY, INTRO, PLAYING, RESULT
            currentGame: null,
            p1Score: 0,
            p2Score: 0,
            timer: 0,
            currentRotation: 0,

            resetPlayers() {
                p1Mesh.position.set(-3, 0, 0);
                p2Mesh.position.set(3, 0, 0);
                p1Mesh.rotation.set(0, Math.PI/2, 0);
                p2Mesh.rotation.set(0, -Math.PI/2, 0);
                p1Mesh.visible = true;
                p2Mesh.visible = true;
            },

            spinWheel() {
                document.getElementById('lobby-card').classList.remove('active');
                document.getElementById('wheel-overlay').classList.add('active');
                
                // Spin Logic
                const extraSpins = 5;
                const randomAngle = Math.floor(Math.random() * 360);
                const totalDegree = (360 * extraSpins) + randomAngle;
                
                // Need to subtract because wheel spins clockwise, so degrees move counter-clockwise relative to pointer at top
                // But pointer is at top (0 deg). 
                // Let's visualize: 0-120 (Red), 120-240 (Green), 240-360 (Gold).
                // If we rotate the wheel -90 deg, Red is at top. 
                // CSS Rotate moves the wheel.
                
                // Let's simply apply rotation
                const wheelEl = document.getElementById('wheel');
                this.currentRotation += totalDegree; // Accumulate to spin forward always
                wheelEl.style.transform = `rotate(-${this.currentRotation}deg)`;
                
                setTimeout(() => {
                    this.resolveWheel(this.currentRotation % 360);
                }, 3100);
            },
            
            resolveWheel(finalAngle) {
                // Determine sector
                // Pointer is at TOP. 
                // Rotate(0) -> Red starts at top (0) to 120.
                // Rotate(-X) means we are moving the wheel CCW.
                // So if we rotate -60, the pointer (at 0) is pointing at 60deg of the wheel.
                // Angle logic:
                // 0-120: BRAWL (Red)
                // 120-240: SURVIVAL (Green)
                // 240-360: COLLECT (Gold)
                
                let type = '';
                if (finalAngle < 120) type = 'BRAWL';
                else if (finalAngle < 240) type = 'SURVIVAL';
                else type = 'COLLECT';
                
                document.getElementById('wheel-overlay').classList.remove('active');
                this.setupMinigame(type);
            },

            setupMinigame(type) {
                this.state = 'INTRO';
                this.currentGame = type;
                document.getElementById('intro-card').classList.add('active');

                // Game Config
                const titles = {
                    'BRAWL': { t: 'Tiki Brawl', d: 'Shoot! Use Crates for Cover! 3 Hits to Win.', p: '1 Sip' },
                    'SURVIVAL': { t: 'Coconut Chaos', d: 'Avoid them! They get faster!', p: '2 Sips' },
                    'COLLECT': { t: 'Pineapple Rush', d: 'First to 5! Golden Pineapple = 3 pts!', p: 'Score Diff' }
                };
                const info = titles[type];
                document.getElementById('game-title').innerText = info.t;
                document.getElementById('game-desc').innerText = info.d;
                document.getElementById('game-penalty').innerText = info.p;

                // Move Arena Up
                arena.position.set(0, 0.1, 0); // Overlay on sand
                islandGroup.visible = false; // Hide messy background
                scene.background = new THREE.Color(0x203040); // Darker BG for focus
                ambientLight.intensity = 0.8;

                // Reset positions for arena
                p1Mesh.position.set(-5, 0.1, 0);
                p2Mesh.position.set(5, 0.1, 0);
                
                // Clear old objects
                gameObjects.forEach(o => scene.remove(o.mesh));
                gameObjects = [];

                // Countdown
                let count = 3;
                const cdEl = document.getElementById('countdown');
                cdEl.innerText = count;
                const int = setInterval(() => {
                    count--;
                    if(count <= 0) {
                        clearInterval(int);
                        cdEl.innerText = "GO!";
                        setTimeout(() => {
                            this.beginGameplay();
                        }, 500);
                    } else {
                        cdEl.innerText = count;
                    }
                }, 1000);
            },

            beginGameplay() {
                document.getElementById('intro-card').classList.remove('active');
                document.getElementById('game-timer').style.display = 'block';
                this.state = 'PLAYING';
                this.p1Score = 0;
                this.p2Score = 0;
                this.timer = 0; // Game time
                
                // Game specific init
                if(this.currentGame === 'BRAWL') {
                    p1Mesh.hp = 3;
                    p2Mesh.hp = 3;
                    spawnObstacles(); // New: Obstacles
                } else if (this.currentGame === 'SURVIVAL') {
                    p1Mesh.hp = 1;
                    p2Mesh.hp = 1;
                }
            },

            endGame(winner) {
                this.state = 'RESULT';
                document.getElementById('game-timer').style.display = 'none';
                
                let text = "";
                let penalty = "";

                if(winner === 1) {
                    text = "PLAYER 1 WINS!";
                    if(this.currentGame === 'BRAWL') penalty = "Player 2 drinks 1 sip";
                    else if(this.currentGame === 'SURVIVAL') penalty = "Player 2 drinks 2 sips";
                    else if(this.currentGame === 'COLLECT') penalty = `Player 2 drinks ${Math.max(1, 5 - this.p2Score)} sips`;
                } else if (winner === 2) {
                    text = "PLAYER 2 WINS!";
                    if(this.currentGame === 'BRAWL') penalty = "Player 1 drinks 1 sip";
                    else if(this.currentGame === 'SURVIVAL') penalty = "Player 1 drinks 2 sips";
                    else if(this.currentGame === 'COLLECT') penalty = `Player 1 drinks ${Math.max(1, 5 - this.p1Score)} sips`;
                } else {
                    text = "DRAW!";
                    penalty = "Everyone drinks 1 sip";
                }

                document.getElementById('winner-text').innerText = text;
                document.getElementById('loser-task').innerText = penalty;
                document.getElementById('result-card').classList.add('active');
            },

            returnToLobby() {
                document.getElementById('result-card').classList.remove('active');
                document.getElementById('lobby-card').classList.add('active');
                
                // Reset Scene
                scene.background = new THREE.Color(0x87CEEB);
                islandGroup.visible = true;
                arena.position.y = 100;
                gameObjects.forEach(o => scene.remove(o.mesh));
                gameObjects = [];
                this.resetPlayers();
                this.state = 'LOBBY';
            }
        };

        GameManager.resetPlayers();

        // --- GAME LOOP ---
        let lastTime = 0;
        let p1ShootCd = 0;
        let p2ShootCd = 0;
        let spawnTimer = 0;

        function animate(time) {
            requestAnimationFrame(animate);
            const dt = (time - lastTime) / 1000;
            lastTime = time;

            // Movement Logic
            const speed = 8 * dt;
            const p1In = Input.getP1Axis();
            const p2In = Input.getP2Axis();

            if (GameManager.state === 'LOBBY' || GameManager.state === 'PLAYING') {
                // P1 Move
                if (p1In.x !== 0 || p1In.z !== 0) {
                    p1Mesh.position.x += p1In.x * speed;
                    p1Mesh.position.z += p1In.z * speed;
                    p1Mesh.lookAt(p1Mesh.position.x + p1In.x, p1Mesh.position.y, p1Mesh.position.z + p1In.z);
                }
                // P2 Move
                if (p2In.x !== 0 || p2In.z !== 0) {
                    p2Mesh.position.x += p2In.x * speed;
                    p2Mesh.position.z += p2In.z * speed;
                    p2Mesh.lookAt(p2Mesh.position.x + p2In.x, p2Mesh.position.y, p2Mesh.position.z + p2In.z);
                }

                // Clamp to arena in game
                if (GameManager.state === 'PLAYING') {
                    const limit = 8;
                    p1Mesh.position.clamp(new THREE.Vector3(-limit,0,-limit), new THREE.Vector3(limit,1,limit));
                    p2Mesh.position.clamp(new THREE.Vector3(-limit,0,-limit), new THREE.Vector3(limit,1,limit));
                }
            }

            // Minigame Logic
            if (GameManager.state === 'PLAYING') {
                GameManager.timer += dt;
                document.getElementById('game-timer').innerText = Math.floor(GameManager.timer);

                // --- GAME 1: BRAWL (Shooting) ---
                if (GameManager.currentGame === 'BRAWL') {
                    // Shooting
                    if(p1ShootCd > 0) p1ShootCd -= dt;
                    if(p1In.action && p1ShootCd <= 0) {
                        spawnProjectile(p1Mesh, 1);
                        p1ShootCd = 0.5;
                    }
                    if(p2ShootCd > 0) p2ShootCd -= dt;
                    if(p2In.action && p2ShootCd <= 0) {
                        spawnProjectile(p2Mesh, 2);
                        p2ShootCd = 0.5;
                    }
                }
                
                // --- GAME 2: SURVIVAL (Coconuts) ---
                if (GameManager.currentGame === 'SURVIVAL') {
                    spawnTimer -= dt;
                    if(spawnTimer <= 0) {
                        spawnFallingCoconut();
                        // Difficulty curve: spawn faster over time
                        spawnTimer = Math.max(0.1, 0.6 - (GameManager.timer * 0.02)); 
                    }
                }

                // --- GAME 3: COLLECT (Pineapples) ---
                if (GameManager.currentGame === 'COLLECT') {
                    spawnTimer -= dt;
                    if(spawnTimer <= 0 && gameObjects.filter(g => g.type === 'pineapple').length < 4) {
                        spawnPineapple();
                        spawnTimer = 2;
                    }
                }

                // Process Objects
                for (let i = gameObjects.length - 1; i >= 0; i--) {
                    const obj = gameObjects[i];
                    
                    if (obj.type === 'projectile') {
                        obj.mesh.position.add(obj.vel.clone().multiplyScalar(dt));
                        
                        // Check Collision with Crates (Obstacles)
                        let hitCrate = false;
                        for(let j=0; j<gameObjects.length; j++) {
                            if(gameObjects[j].type === 'obstacle' && obj.mesh.position.distanceTo(gameObjects[j].mesh.position) < 1.5) {
                                hitCrate = true; break;
                            }
                        }

                        // Check Collision with Players
                        const distP1 = obj.mesh.position.distanceTo(p1Mesh.position);
                        const distP2 = obj.mesh.position.distanceTo(p2Mesh.position);
                        
                        if (hitCrate) {
                            removeObj(i);
                        } else if(obj.owner !== 1 && distP1 < 1) {
                            p1Mesh.hp--; removeObj(i);
                            flashHit(p1Mesh);
                            if(p1Mesh.hp <= 0) GameManager.endGame(2);
                        } else if(obj.owner !== 2 && distP2 < 1) {
                            p2Mesh.hp--; removeObj(i);
                            flashHit(p2Mesh);
                            if(p2Mesh.hp <= 0) GameManager.endGame(1);
                        } else if (obj.mesh.position.length() > 20) {
                            removeObj(i);
                        }
                    }

                    else if (obj.type === 'coconut') {
                        obj.mesh.position.y -= (10 + GameManager.timer) * dt; // Fall faster over time
                        if(obj.mesh.position.y < 0) {
                            const distP1 = obj.mesh.position.distanceTo(p1Mesh.position);
                            const distP2 = obj.mesh.position.distanceTo(p2Mesh.position);
                            if(distP1 < 1.5) GameManager.endGame(2);
                            else if(distP2 < 1.5) GameManager.endGame(1);
                            removeObj(i);
                        }
                        if(obj.shadow) obj.shadow.scale.setScalar(1 + (10 - obj.mesh.position.y)*0.1);
                    }

                    else if (obj.type === 'pineapple') {
                        obj.mesh.rotation.y += dt * 2;
                        const distP1 = obj.mesh.position.distanceTo(p1Mesh.position);
                        const distP2 = obj.mesh.position.distanceTo(p2Mesh.position);
                        
                        if(distP1 < 1) {
                            GameManager.p1Score += obj.value; removeObj(i);
                            checkCollectionWin();
                        } else if (distP2 < 1) {
                            GameManager.p2Score += obj.value; removeObj(i);
                            checkCollectionWin();
                        }
                    }
                }
            }

            // Camera Follow
            if (GameManager.state === 'LOBBY') {
                camera.position.set(0, 15, 20);
                camera.lookAt(0, 0, 0);
            } else {
                camera.position.set(0, 18, 12); // Top down view for game
                camera.lookAt(0, 0, 0);
            }

            renderer.render(scene, camera);
        }

        function spawnObstacles() {
            // Spawn 4 crates
            const pos = [
                {x: -3, z: -3}, {x: 3, z: 3}, {x: -3, z: 3}, {x: 3, z: -3}
            ];
            pos.forEach(p => {
                const mesh = new THREE.Mesh(new THREE.BoxGeometry(1.5, 1.5, 1.5), mats.crate);
                mesh.position.set(p.x, 0.75, p.z);
                scene.add(mesh);
                gameObjects.push({ type: 'obstacle', mesh: mesh });
            });
        }

        function spawnProjectile(player, ownerId) {
            const geom = new THREE.SphereGeometry(0.3);
            const mat = new THREE.MeshBasicMaterial({color: 0xffff00});
            const mesh = new THREE.Mesh(geom, mat);
            mesh.position.copy(player.position);
            mesh.position.y = 0.8;
            
            // Get forward vector
            const forward = new THREE.Vector3(0, 0, 1).applyAxisAngle(new THREE.Vector3(0,1,0), player.rotation.y);
            
            scene.add(mesh);
            gameObjects.push({ type: 'projectile', mesh: mesh, vel: forward.multiplyScalar(20), owner: ownerId });
        }

        function spawnFallingCoconut() {
            const x = (Math.random() - 0.5) * 14;
            const z = (Math.random() - 0.5) * 14;
            const geom = new THREE.SphereGeometry(0.5);
            const mat = new THREE.MeshStandardMaterial({color: 0x5c4033});
            const mesh = new THREE.Mesh(geom, mat);
            mesh.position.set(x, 10, z);
            scene.add(mesh);

            // Warning Shadow
            const sGeo = new THREE.CircleGeometry(0.5, 16);
            const shadow = new THREE.Mesh(sGeo, mats.red);
            shadow.rotation.x = -Math.PI/2;
            shadow.position.set(x, 0.2, z);
            scene.add(shadow);
            
            gameObjects.push({ type: 'coconut', mesh: mesh, shadow: shadow });
        }

        function spawnPineapple() {
            const isGolden = Math.random() > 0.8; // 20% chance
            const x = (Math.random() - 0.5) * 14;
            const z = (Math.random() - 0.5) * 14;
            const color = isGolden ? 0xFFD700 : 0xFFFF00;
            const scale = isGolden ? 0.8 : 0.6;
            
            const mesh = new THREE.Mesh(new THREE.IcosahedronGeometry(scale), new THREE.MeshStandardMaterial({color: color, metalness: isGolden?0.8:0.2, roughness: 0.2}));
            mesh.position.set(x, 0.5, z);
            scene.add(mesh);
            gameObjects.push({ type: 'pineapple', mesh: mesh, value: isGolden ? 3 : 1 });
        }

        function removeObj(index) {
            const obj = gameObjects[index];
            scene.remove(obj.mesh);
            if(obj.shadow) scene.remove(obj.shadow);
            gameObjects.splice(index, 1);
        }

        function flashHit(mesh) {
            mesh.children[0].material.color.setHex(0xffffff);
            setTimeout(() => {
                if(mesh === p1Mesh) mesh.children[0].material.color.setHex(0x00ffaa);
                else mesh.children[0].material.color.setHex(0xff00ff);
            }, 100);
        }

        function checkCollectionWin() {
            if(GameManager.p1Score >= 5) GameManager.endGame(1);
            else if(GameManager.p2Score >= 5) GameManager.endGame(2);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate(0);

    </script>
</body>
</html>